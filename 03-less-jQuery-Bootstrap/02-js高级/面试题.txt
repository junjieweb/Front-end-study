闭包（面试题）
	1. 如何产生闭包(条件)?
 	 	* 函数嵌套
  	 	* 内部函数引用外部函数的局部变量
 	 	* 使用（调用）外部函数




		 //并且内部函数也要调用或者引用（针对谷歌）（因为部分浏览器会对内部函数做优化，内部函数不使用或者不引用，相当于没有）；




	2. 闭包到底是什么?
  	 	* 理解一: 闭包是嵌套的内部函数(绝大部分人)
  	 	* 理解二: 包含被引用变量(外部函数)的对象(极少数人)
  	 	* 理解三： 所谓的闭包是一个引用关系，该引用关系存在于内部函数中，引用的是外部函数的变量的对象(深入理解)



	3、常见的闭包
		1. 将函数作为另一个函数的返回值
		2. 将函数作为实参传递给另一个函数调用
		3. 使用闭包实现私有方法操作独立的私有属性



	4、闭包的作用
		1. 延长外部函数变量对象的生命周期
		2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数),通过闭包间接的操作
		3. 注意： 浏览器为了性能后期将外部函数中不被内部函数使用的变量清除了

	5、闭包的生命周期

		1. 产生: 在嵌套内部函数定义完时就产生了(不是在调用)，外部函数调用的时候
		2. 死亡: 在嵌套的内部函数成为垃圾对象时

	6、自定义模块（模块化）	
  		* 具有特定功能的js文件
  		* 将所有的数据和功能都封装在一个函数内部(私有的)
  		* 只向外暴露一个包含n个方法的对象或函数
  		* 模块的使用者, 只需要通过模块暴露的对象调用方法来实现对应的功能
		使用自调用和不使用自调用函数区别

	7、闭包的缺点和解决(内存泄漏和内存溢出)

		内存泄漏 ： 内存无法释放；
		内存溢出 ： 内存被撑爆；
		f = null;  解决方式；让闭包机制清除，必须删除外部函数调用的时候生成的（定义的那个对应内部函数）；

	8、面试题

		//代码片段一
  		var name = "The Window";
  		var object = {
    			name: "My Object",
    			getNameFunc: function () {
				
      				return function () {
        				return this.name;
      				};
    		     	}
  		};
  		console.log(object.getNameFunc()());  

  		//代码片段二
  		var name2 = "The Window";
  		var object2 = {
    			name2: "My Object",
    			getNameFunc: function () {
      				var that = this;
      				return function () {
        				return that.name2;
      				};
    			}
  		};
  		console.log(object2.getNameFunc()());	


		 //代码片段三

  		function fun(n, o) {
    			console.log(o)
    			return {
      				fun: function (m) {
        				return fun(m, n)
      				}
    			}
  		}


  		var a = fun(0)  
  		a.fun(1)  
  		a.fun(2) 
  		a.fun(3) 


  		var b = fun(0).fun(1).fun(2).fun(3) 



七、面向对象（原型继承、构造函数继承、组合继承）    面向对象三大特性：封装继承多态
	原型继承

		让父类的实例作为子类的原型，将子类的原型构造器补充完整 （为了让子类继承方法）

	借用构造函数继承
		在子类当中去调用父类的构造函数，当普通函数调用（为了让子类继承属性）


	组合继承（原型继承方法，借用构造函数继承属性一起使用）
	

八、事件循环机制
	多进程和多线程
		1. 进程：程序的一次执行, 它占有一片独有的内存空间
		2. 线程： CPU的基本调度单位, 是程序执行的一个完整流程
		3. 进程与线程
  			* 一个进程中一般至少有一个运行的线程: 主线程
  			* 一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的
  			* 一个进程内的数据可以供其中的多个线程直接共享
  			* 多个进程之间的数据是不能直接共享的


		4. 浏览器运行是单进程还是多进程?
  			* 有的是单进程
    				* firefox
    				* 老版IE
  			* 有的是多进程
    				* chrome
    				* 新版IE
		5. 如何查看浏览器是否是多进程运行的呢?
  			* 任务管理器==>进程

		6. 浏览器运行是单线程还是多线程?
  			* 都是多线程运行的

	js是单线程的
		1. 如何证明js执行是单线程的?
  			* setTimeout()的回调函数是在主线程执行的
  			* 定时器回调函数只有在运行栈中的代码全部执行完后才有可能执行
		2. 为什么js要用单线程模式, 而不用多线程模式?
  			* JavaScript的单线程，与它的用途有关。
  			* 作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。
  			* 这决定了它只能是单线程，否则会带来很复杂的同步问题

		3. 代码的分类:
  			* 初始化代码（同步代码）
  			* 回调代码

		4. js引擎执行代码的基本流程
  			* 先执行初始化代码: 包含一些特别的代码
    			* 设置定时器
    			* 绑定监听
    			* 发送ajax请求
  			* 后面在某个时刻才会执行回调代码
	
	同步    同步执行完成才会去执行异步

	异步	只要是异步的任务都会有自己的管理模块进行托管

	回调
		事件
		定时器
		ajax
		生命周期回调函数

	事件循环模型

		1. 所有代码分类
  			* 初始化执行代码(同步代码): 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
  			* 回调执行代码(异步代码): 处理回调逻辑
		2. js引擎执行代码的基本流程:
  			* 初始化代码===>回调代码
		3. 模型的2个重要组成部分:
  			* 事件管理模块
  			* 回调队列
		4. 模型的运转流程
  			* 执行初始化代码, 将事件回调函数交给对应模块管理
  			* 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
  			* 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行


	Web Workers模拟多线程
		1. H5规范提供了js分线程的实现, 取名为: Web Worker
		2. 相关API
  			* Worker: 构造函数, 加载分线程执行的js文件
  			* Worker.prototype.onmessage: 用于接收另一个线程的回调函数
  			* Worker.prototype.postMessage: 向另一个线程发送消息

			每个线程可以向不同线程发送消息  也可以接收不同线程传来的消息
			
			主线程操作
				发送消息：   worker.postMessage(消息可以是任何数据)
				接受消息：   worker.onmessage = function(e){
						console.log(e.data)//接收到的消息或者数据在事件对象的data属性当中
				    	    }

		
			子线程操作
				发送消息：   this.postMessage(消息可以是任何数据)
				接受消息：   this.onmessage = function(e){
						console.log(e.data)//接收到的消息或者数据在事件对象的data属性当中
				     	    }
			
						
		3. 不足
  			* worker内代码不能操作DOM(更新UI)
  			* 不能跨域加载JS
  			* 不是每个浏览器都支持这个新特性
	

			













