<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>玉树临风美少年，揽镜自顾夜不眠 </title>
</head>

<body>
  <script type="text/javascript">

    // 1. 一个问题:谈谈你对闭包的理解？ 闭包什么时候产生的,闭包是啥,为什么有闭包,闭包的优缺点,应用
    // 2. 三连问,或者是:五连问:  什么是闭包? 为什么要有闭包? 闭包有什么作用,有什么优缺点?


    // 执行函数定义(定义的函数执行了,里面的函数体代码是没有执行的) 和执行函数(调用函数---内部函数体代码执行了) 两回事

    // 情况1
    // function fn1() {
    //   var a = 2;
    //   // fn2 是引用变量,存储的是该函数对象所在的内存空间的地址,此时就说明函数对象已经创建了
    //   function fn2() {
    //     a++;
    //     console.log(a);
    //     // console.log('今天是元宵节,晚上吃点啥呢')
    //   }
    //   return fn2;
    // }
    // // fn1()
    // var f = fn1();
    // f();
    // 函数之间有嵌套关系,内部函数中使用到了外部函数中的变量,内部函数在执行该函数定义的时候,就形成了闭包
    // 函数之间有嵌套关系,内部函数调用的时候,用到了外部函数中的变量,此时形成了闭包

    // 执行外部函数,内部函数使用了外部函数的变量,执行内部函数定义,此时可以形成闭包
    // 执行外部函数,内部函数使用了外部函数的变量,内部函数对象创建了,此时可以形成闭包
    // 外部函数调用了,内部函数中用到了外部函数中的变量,内部函数的定义也执行了,此时形成了闭包
    // 执行外部函数,内部函数中没有使用外部函数中的变量,此时执行内部函数定义,没有形成闭包
    // fn1 函数调用后,函数内部中的局部的变量的或者说局部作用域中所使用的数据全都释放了,没了,
    // 但是fn1函数调用后返回的fn2是一个引用变量,该变量中存储的是fn2函数对象所在的空间的地址
    // 此时fn2中存储的是一个地址,整个地址给了f,f是一个引用变量,存储的就是fn2函数对象所在的空间的地址
    // 此时的f 和fn2中存储的函数对象,还有着引用关系, 既然有引用关系,那么就说明fn1函数调用后,内部的数据被缓存起来了,没有被释放掉,所以,f函数调用后,可以再次进入到fn2函数中(不是此时形成的闭包,而是再用这个闭包,闭包之前就已经形成了)

      // 函数有嵌套,外部函数调用了,内部函数使用了外部函数中的变量,但是内部函数是函数表达式的方式,只有内部函数定义执行了,那么此时才会形成闭包,如果fn2引用变量中还是undefined,此时没有执行,那么闭包就没有产生
      // 闭包也是对象

    // 情况2

    // function fn1() {
    //   var a = 2;
    //   // fn2此时是一个引用变量,内部存储的是一个函数对象所在的空间的地址
    //   var fn2 = function() {
    //     a++;
    //     console.log(a);
    //   }
    //   return fn2;
    // }
    // // f就是一个引用变量了,内部存储的地址和fn2引用变量中存储的地址是一样的,
    // var f = fn1();
    //   // 此时还有没有释放
    // f();
  
    // var ff = f
    // // 此时依然没有释放
    // ff = null // 就释放了
    // ff()
    // f=null // 那么此时就释放了






    // function fn1() {
    //   var a = 2;
    //   function fn2() {
    //     a++;
    //     console.log(a);
    //   }
    //   return fn2;
    // }
    // var f = fn1();
    // f();
    // f();
    // var f2 = f
    // f = null


    // function showDedelay(time, msg) {
    //   setTimeout(() => {
    //     alert(msg)
    //   }, time)
    // }
    // showDedelay(1000)
    // // 释放
    // clearTimeout()


    

  </script>
</body>

</html>